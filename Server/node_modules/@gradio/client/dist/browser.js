const Je = "host", Re = "queue/data", He = "queue/join", ge = "upload", We = "login", Z = "config", Ze = "info", Ke = "runtime", Ve = "sleeptime", Ye = "heartbeat", Qe = "component_server", Xe = "reset", et = "cancel", tt = "app_id", Oe = "This application is currently busy. Please try again. ", M = "Connection errored out. ", N = "Could not resolve app config. ", st = "Could not get space status. ", nt = "Could not get API info. ", ce = "Space metadata could not be loaded. ", ot = "Invalid URL. A full URL path is required.", it = "Not authorized to access this space. ", Te = "Invalid credentials. Could not login. ", rt = "Login credentials are required to access this space.", at = "File system access is only available in Node.js environments", Ae = "Root URL not found in client config", ct = "Error uploading file";
async function we(e, s, t) {
  try {
    return (await (await fetch(`https://huggingface.co/api/spaces/${e}/jwt`, {
      headers: {
        Authorization: `Bearer ${s}`,
        ...t ? { Cookie: t } : {}
      }
    })).json()).token || !1;
  } catch {
    return !1;
  }
}
function ut(e) {
  let s = {};
  return e.forEach(({ api_name: t, id: n }) => {
    t && (s[t] = n);
  }), s;
}
async function lt(e) {
  const s = this.options.token ? { Authorization: `Bearer ${this.options.token}` } : {};
  if (s["Content-Type"] = "application/json", typeof window < "u" && window.gradio_config && location.origin !== "http://localhost:9876") {
    if (window.gradio_config.current_page && (e = e.substring(0, e.lastIndexOf("/"))), window.gradio_config.dev_mode) {
      let t = re(
        e,
        this.deep_link ? Z + "?deep_link=" + this.deep_link : Z
      );
      const n = await this.fetch(t, {
        headers: s,
        credentials: "include"
      }), i = await ye(
        n,
        e,
        !!this.options.auth
      );
      window.gradio_config = {
        ...i,
        current_page: window.gradio_config.current_page
      };
    }
    return window.gradio_config.root = e, { ...window.gradio_config };
  } else if (e) {
    let t = re(
      e,
      this.deep_link ? Z + "?deep_link=" + this.deep_link : Z
    );
    const n = await this.fetch(t, {
      headers: s,
      credentials: "include"
    });
    return ye(n, e, !!this.options.auth);
  }
  throw new Error(N);
}
async function ye(e, s, t) {
  if (e?.status === 401 && !t) {
    const i = (await e.json())?.detail?.auth_message;
    throw new Error(i || rt);
  } else if (e?.status === 401 && t)
    throw new Error(Te);
  if (e?.status === 200) {
    let n = await e.json();
    return n.root = s, n.dependencies?.forEach((i, o) => {
      i.id === void 0 && (i.id = o);
    }), n;
  } else if (e?.status === 401)
    throw new Error(it);
  throw new Error(N);
}
async function pt() {
  const { http_protocol: e, host: s } = await le(
    this.app_reference,
    this.options.token
  );
  try {
    if (this.options.auth) {
      const t = await xe(
        e,
        s,
        this.options.auth,
        this.fetch,
        this.options.token
      );
      t && this.set_cookies(t);
    }
  } catch (t) {
    throw Error(t.message);
  }
}
async function xe(e, s, t, n, i) {
  const o = new FormData();
  o.append("username", t?.[0]), o.append("password", t?.[1]);
  let r = {};
  i && (r.Authorization = `Bearer ${i}`);
  const a = await n(`${e}//${s}/${We}`, {
    headers: r,
    method: "POST",
    body: o,
    credentials: "include"
  });
  if (a.status === 200)
    return a.headers.get("set-cookie");
  throw a.status === 401 ? new Error(Te) : new Error(ce);
}
function ie(e) {
  if (e.startsWith("http")) {
    const { protocol: s, host: t, pathname: n } = new URL(e);
    return {
      ws_protocol: s === "https:" ? "wss" : "ws",
      http_protocol: s,
      host: t + (n !== "/" ? n : "")
    };
  }
  return {
    ws_protocol: "wss",
    http_protocol: "https:",
    host: new URL(e).host
  };
}
const Ce = (e) => {
  let s = [];
  return e.split(/,(?=\s*[^\s=;]+=[^\s=;]+)/).forEach((n) => {
    const [i, o] = n.split(";")[0].split("=");
    i && o && s.push(`${i.trim()}=${o.trim()}`);
  }), s;
}, ue = /^[a-zA-Z0-9_\-\.]+\/[a-zA-Z0-9_\-\.]+$/, ht = /.*hf\.space\/{0,1}.*$/;
async function le(e, s) {
  const t = {};
  s && (t.Authorization = `Bearer ${s}`);
  const n = e.trim().replace(/\/$/, "");
  if (ue.test(n))
    try {
      const o = (await (await fetch(
        `https://huggingface.co/api/spaces/${n}/${Je}`,
        { headers: t }
      )).json()).host;
      return {
        space_id: e,
        ...ie(o)
      };
    } catch {
      throw new Error(ce);
    }
  if (ht.test(n)) {
    const { ws_protocol: i, http_protocol: o, host: r } = ie(n);
    return {
      space_id: r.split("/")[0].replace(".hf.space", ""),
      ws_protocol: i,
      http_protocol: o,
      host: r
    };
  }
  return {
    space_id: !1,
    ...ie(n)
  };
}
const re = (...e) => {
  try {
    return e.reduce((s, t) => (s = s.replace(/\/+$/, ""), t = t.replace(/^\/+/, ""), new URL(t, s + "/").toString()));
  } catch {
    throw new Error(ot);
  }
};
function dt(e, s, t) {
  const n = {
    named_endpoints: {},
    unnamed_endpoints: {}
  };
  return Object.keys(e).forEach((i) => {
    (i === "named_endpoints" || i === "unnamed_endpoints") && (n[i] = {}, Object.entries(e[i]).forEach(
      ([o, { parameters: r, returns: a }]) => {
        const u = s.dependencies.find(
          (c) => c.api_name === o || c.api_name === o.replace("/", "")
        )?.id || t[o.replace("/", "")] || -1, l = u !== -1 ? s.dependencies.find((c) => c.id == u)?.types : { generator: !1, cancel: !1 };
        if (u !== -1 && s.dependencies.find((c) => c.id == u)?.inputs?.length !== r.length) {
          const c = s.dependencies.find((m) => m.id == u).inputs.map(
            (m) => s.components.find((w) => w.id === m)?.type
          );
          try {
            c.forEach((m, w) => {
              if (m === "state") {
                const h = {
                  component: "state",
                  example: null,
                  parameter_default: null,
                  parameter_has_default: !0,
                  parameter_name: null,
                  hidden: !0
                };
                r.splice(w, 0, h);
              }
            });
          } catch (m) {
            console.error(m);
          }
        }
        const p = (c, m, w, h) => ({
          ...c,
          description: _t(c?.type, w),
          type: ft(c?.type, m, w, h) || ""
        });
        n[i][o] = {
          parameters: r.map(
            (c) => p(c, c?.component, c?.serializer, "parameter")
          ),
          returns: a.map(
            (c) => p(c, c?.component, c?.serializer, "return")
          ),
          type: l
        };
      }
    ));
  }), n;
}
function ft(e, s, t, n) {
  if (s === "Api") return e.type;
  switch (e?.type) {
    case "string":
      return "string";
    case "boolean":
      return "boolean";
    case "number":
      return "number";
  }
  if (t === "JSONSerializable" || t === "StringSerializable")
    return "any";
  if (t === "ListStringSerializable")
    return "string[]";
  if (s === "Image")
    return n === "parameter" ? "Blob | File | Buffer" : "string";
  if (t === "FileSerializable")
    return e?.type === "array" ? n === "parameter" ? "(Blob | File | Buffer)[]" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]" : n === "parameter" ? "Blob | File | Buffer" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}";
  if (t === "GallerySerializable")
    return n === "parameter" ? "[(Blob | File | Buffer), (string | null)][]" : "[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]";
}
function _t(e, s) {
  return s === "GallerySerializable" ? "array of [file, label] tuples" : s === "ListStringSerializable" ? "array of strings" : s === "FileSerializable" ? "array of files or single file" : e?.description;
}
function be(e, s) {
  switch (e.msg) {
    case "send_data":
      return { type: "data" };
    case "send_hash":
      return { type: "hash" };
    case "queue_full":
      return {
        type: "update",
        status: {
          queue: !0,
          message: Oe,
          stage: "error",
          code: e.code,
          success: e.success
        }
      };
    case "heartbeat":
      return {
        type: "heartbeat"
      };
    case "unexpected_error":
      return {
        type: "unexpected_error",
        status: {
          queue: !0,
          message: e.message,
          session_not_found: e.session_not_found,
          stage: "error",
          success: !1
        }
      };
    case "broken_connection":
      return {
        type: "broken_connection",
        status: {
          queue: !0,
          message: e.message,
          stage: "error",
          success: !1
        }
      };
    case "estimation":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: s || "pending",
          code: e.code,
          size: e.queue_size,
          position: e.rank,
          eta: e.rank_eta,
          success: e.success
        }
      };
    case "progress":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: "pending",
          code: e.code,
          progress_data: e.progress_data,
          success: e.success
        }
      };
    case "log":
      return { type: "log", data: e };
    case "process_generating":
      return {
        type: "generating",
        status: {
          queue: !0,
          message: e.success ? null : e.output.error,
          stage: e.success ? "generating" : "error",
          code: e.code,
          progress_data: e.progress_data,
          eta: e.average_duration,
          changed_state_ids: e.success ? e.output.changed_state_ids : void 0
        },
        data: e.success ? e.output : null
      };
    case "process_streaming":
      return {
        type: "streaming",
        status: {
          queue: !0,
          message: e.output.error,
          stage: "streaming",
          time_limit: e.time_limit,
          code: e.code,
          progress_data: e.progress_data,
          eta: e.eta
        },
        data: e.output
      };
    case "process_completed":
      return "error" in e.output ? {
        type: "update",
        status: {
          queue: !0,
          title: e.output.title ?? "Error",
          message: e.output.error ?? "An error occurred",
          visible: e.output.visible,
          duration: e.output.duration,
          stage: "error",
          code: e.code,
          success: e.success
        }
      } : {
        type: "complete",
        status: {
          queue: !0,
          message: e.success ? void 0 : e.output.error,
          stage: e.success ? "complete" : "error",
          code: e.code,
          progress_data: e.progress_data,
          changed_state_ids: e.success ? e.output.changed_state_ids : void 0
        },
        data: e.success ? e.output : null
      };
    case "process_starts":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: "pending",
          code: e.code,
          size: e.rank,
          position: 0,
          success: e.success,
          eta: e.eta
        },
        original_msg: "process_starts"
      };
  }
  return { type: "none", status: { stage: "error", queue: !0 } };
}
const mt = (e = [], s) => {
  const t = s ? s.parameters : [];
  if (Array.isArray(e))
    return s && t.length > 0 && e.length > t.length && console.warn("Too many arguments provided for the endpoint."), e;
  const n = [], i = Object.keys(e);
  return t.forEach((o, r) => {
    if (e.hasOwnProperty(o.parameter_name))
      n[r] = e[o.parameter_name];
    else if (o.parameter_has_default)
      n[r] = o.parameter_default;
    else
      throw new Error(
        `No value provided for required parameter: ${o.parameter_name}`
      );
  }), i.forEach((o) => {
    if (!t.some((r) => r.parameter_name === o))
      throw new Error(
        `Parameter \`${o}\` is not a valid keyword argument. Please refer to the API for usage.`
      );
  }), n.forEach((o, r) => {
    if (o === void 0 && !t[r].parameter_has_default)
      throw new Error(
        `No value provided for required parameter: ${t[r].parameter_name}`
      );
  }), n;
};
async function gt() {
  if (this.api_info) return this.api_info;
  const { token: e } = this.options, { config: s } = this, t = { "Content-Type": "application/json" };
  if (e && (t.Authorization = `Bearer ${e}`), !!s)
    try {
      let n, i;
      if (typeof window < "u" && window.gradio_api_info)
        i = window.gradio_api_info;
      else {
        const o = re(s.root, this.api_prefix, Ze);
        if (n = await this.fetch(o, {
          headers: t,
          credentials: "include"
        }), !n.ok)
          throw new Error(M);
        i = await n.json();
      }
      return "api" in i && (i = i.api), i.named_endpoints["/predict"] && !i.unnamed_endpoints[0] && (i.unnamed_endpoints[0] = i.named_endpoints["/predict"]), dt(i, s, this.api_map);
    } catch (n) {
      throw new Error("Could not get API info. " + n.message);
    }
}
async function wt(e, s, t) {
  const n = {};
  this?.options?.token && (n.Authorization = `Bearer ${this.options.token}`);
  const i = 1e3, o = [];
  let r;
  for (let a = 0; a < s.length; a += i) {
    const u = s.slice(a, a + i), l = new FormData();
    u.forEach((c) => {
      l.append("files", c);
    });
    try {
      const c = t ? `${e}${this.api_prefix}/${ge}?upload_id=${t}` : `${e}${this.api_prefix}/${ge}`;
      r = await this.fetch(c, {
        method: "POST",
        body: l,
        headers: n,
        credentials: "include"
      });
    } catch (c) {
      throw new Error(M + c.message);
    }
    if (!r.ok) {
      const c = await r.text();
      return { error: `HTTP ${r.status}: ${c}` };
    }
    const p = await r.json();
    p && o.push(...p);
  }
  return { files: o };
}
const yt = {
  radix: 1e3,
  unit: ["b", "kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"]
}, bt = {
  radix: 1024,
  unit: ["b", "Kib", "Mib", "Gib", "Tib", "Pib", "Eib", "Zib", "Yib"]
}, vt = {
  radix: 1024,
  unit: ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"]
}, ve = {
  si: yt,
  iec: bt,
  jedec: vt
};
function Et(e, s = 1, t = "jedec") {
  e = Math.abs(e);
  const { radix: n, unit: i } = ve[t] || ve.jedec;
  let o = 0;
  for (; e >= n; )
    e /= n, ++o;
  return `${e.toFixed(s)} ${i[o]}`;
}
async function St(e, s, t, n) {
  let i = (Array.isArray(e) ? e : [e]).map(
    (r) => r.blob
  );
  const o = i.filter(
    (r) => r.size > (n ?? 1 / 0)
  );
  if (o.length)
    throw new Error(
      `File(s) exceed the maximum allowed size of ${Et(n || 1 / 0)}: ${o.map((r) => `"${r.name}"`).join(", ")}`
    );
  return await Promise.all(
    await this.upload_files(s, i, t).then(
      async (r) => {
        if (r.error)
          throw new Error(r.error);
        return r.files ? r.files.map((a, u) => new Y({
          ...e[u],
          path: a,
          url: `${s}${this.api_prefix}/file=${a}`
        })) : [];
      }
    )
  );
}
async function Yt(e, s) {
  return e.map(
    (t) => new Y({
      path: t.name,
      orig_name: t.name,
      blob: t,
      size: t.size,
      mime_type: t.type,
      is_stream: s
    })
  );
}
class Y {
  path;
  url;
  orig_name;
  size;
  blob;
  is_stream;
  mime_type;
  alt_text;
  b64;
  meta = { _type: "gradio.FileData" };
  constructor({
    path: s,
    url: t,
    orig_name: n,
    size: i,
    blob: o,
    is_stream: r,
    mime_type: a,
    alt_text: u,
    b64: l
  }) {
    this.path = s, this.url = t, this.orig_name = n, this.size = i, this.blob = t ? void 0 : o, this.is_stream = r, this.mime_type = a, this.alt_text = u, this.b64 = l;
  }
}
class Ne {
  type;
  command;
  meta;
  fileData;
  constructor(s, t) {
    this.type = "command", this.command = s, this.meta = t;
  }
}
const $t = typeof process < "u" && process.versions && process.versions.node;
function Ee(e, s, t) {
  for (; t.length > 1; ) {
    const i = t.shift();
    if (typeof i == "string" || typeof i == "number")
      e = e[i];
    else
      throw new Error("Invalid key type");
  }
  const n = t.shift();
  if (typeof n == "string" || typeof n == "number")
    e[n] = s;
  else
    throw new Error("Invalid key type");
}
async function ae(e, s = void 0, t = [], n = !1, i = void 0) {
  if (Array.isArray(e)) {
    let o = [];
    return await Promise.all(
      e.map(async (r, a) => {
        let u = t.slice();
        u.push(String(a));
        const l = await ae(
          e[a],
          n ? i?.parameters[a]?.component || void 0 : s,
          u,
          !1,
          i
        );
        o = o.concat(l);
      })
    ), o;
  } else {
    if (globalThis.Buffer && e instanceof globalThis.Buffer || e instanceof Blob)
      return [
        {
          path: t,
          blob: new Blob([e]),
          type: s
        }
      ];
    if (typeof e == "object" && e !== null) {
      let o = [];
      for (const r of Object.keys(e)) {
        const a = [...t, r], u = e[r];
        o = o.concat(
          await ae(
            u,
            void 0,
            a,
            !1,
            i
          )
        );
      }
      return o;
    }
  }
  return [];
}
function kt(e, s) {
  let t = s?.dependencies?.find((n) => n.id == e)?.queue;
  return t != null ? !t : !s.enable_queue;
}
function Rt(e, s) {
  return new Promise((t, n) => {
    const i = new MessageChannel();
    i.port1.onmessage = (({ data: o }) => {
      i.port1.close(), t(o);
    }), window.parent.postMessage(e, s, [i.port2]);
  });
}
function Qt(e) {
  if (typeof e == "string") {
    if (e.startsWith("http://") || e.startsWith("https://"))
      return {
        path: e,
        url: e,
        orig_name: e.split("/").pop() ?? "unknown",
        meta: { _type: "gradio.FileData" }
      };
    if ($t)
      return new Ne("upload_file", {
        path: e,
        name: e,
        orig_path: e
      });
  } else {
    if (typeof File < "u" && e instanceof File)
      return new Blob([e]);
    if (e instanceof Buffer)
      return new Blob([e]);
    if (e instanceof Blob)
      return e;
  }
  throw new Error(
    "Invalid input: must be a URL, File, Blob, or Buffer object."
  );
}
function K(e, s, t, n, i = !1) {
  if (n === "input" && !i)
    throw new Error("Invalid code path. Cannot skip state inputs for input.");
  if (n === "output" && i)
    return e;
  let o = [], r = 0;
  const a = n === "input" ? s.inputs : s.outputs;
  for (let u = 0; u < a.length; u++) {
    const l = a[u];
    if (t.find((c) => c.id === l)?.type === "state") {
      if (i)
        if (e.length === a.length) {
          const c = e[r];
          o.push(c), r++;
        } else
          o.push(null);
      else {
        r++;
        continue;
      }
      continue;
    } else {
      const c = e[r];
      o.push(c), r++;
    }
  }
  return o;
}
async function Ot(e, s, t) {
  const n = this;
  await Tt(n, s);
  const i = await ae(
    s,
    void 0,
    [],
    !0,
    t
  );
  return (await Promise.all(
    i.map(async ({ path: r, blob: a, type: u }) => {
      if (!a) return { path: r, type: u };
      const l = await n.upload_files(e, [a]), p = l.files && l.files[0];
      return {
        path: r,
        file_url: p,
        type: u,
        name: typeof File < "u" && a instanceof File ? a?.name : void 0
      };
    })
  )).forEach(({ path: r, file_url: a, type: u, name: l }) => {
    if (u === "Gallery")
      Ee(s, a, r);
    else if (a) {
      const p = new Y({ path: a, orig_name: l });
      Ee(s, p, r);
    }
  }), s;
}
async function Tt(e, s) {
  if (!(e.config?.root || e.config?.root_url))
    throw new Error(Ae);
  await De(e, s);
}
async function De(e, s, t = []) {
  for (const n in s)
    s[n] instanceof Ne ? await At(e, s, n) : typeof s[n] == "object" && s[n] !== null && await De(e, s[n], [...t, n]);
}
async function At(e, s, t) {
  let n = s[t];
  const i = e.config?.root || e.config?.root_url;
  if (!i)
    throw new Error(Ae);
  try {
    let o, r;
    if (typeof process < "u" && process.versions && process.versions.node) {
      const p = await import("./__vite-browser-external-DYxpcVy9.js");
      r = (await import("./__vite-browser-external-DYxpcVy9.js")).resolve(process.cwd(), n.meta.path), o = await p.readFile(r);
    } else
      throw new Error(at);
    const a = new Blob([o], {
      type: "application/octet-stream"
    }), u = await e.upload_files(i, [a]), l = u.files && u.files[0];
    if (l) {
      const p = new Y({
        path: l,
        orig_name: n.meta.name || ""
      });
      s[t] = p;
    }
  } catch (o) {
    console.error(ct, o);
  }
}
async function xt(e, s, t) {
  const n = { "Content-Type": "application/json" };
  this.options.token && (n.Authorization = `Bearer ${this.options.token}`);
  try {
    var i = await this.fetch(e, {
      method: "POST",
      body: JSON.stringify(s),
      headers: { ...n, ...t },
      credentials: "include"
    });
  } catch {
    return [{ error: M }, 500];
  }
  let o, r;
  try {
    o = await i.json(), r = i.status;
  } catch (a) {
    o = { error: `Could not parse server response: ${a}` }, r = 500;
  }
  return [o, r];
}
async function Ct(e, s = {}) {
  let t = !1, n = !1;
  if (!this.config)
    throw new Error("Could not resolve app config");
  if (typeof e == "number")
    this.config.dependencies.find((i) => i.id == e);
  else {
    const i = e.replace(/^\//, "");
    this.config.dependencies.find(
      (o) => o.id == this.api_map[i]
    );
  }
  return new Promise(async (i, o) => {
    const r = this.submit(e, s, null, null, !0);
    let a;
    for await (const u of r)
      u.type === "data" && (n && i(a), t = !0, a = u), u.type === "status" && (u.stage === "error" && o(u), u.stage === "complete" && (n = !0, t && i(a)));
  });
}
async function G(e, s, t) {
  let n = s === "subdomain" ? `https://huggingface.co/api/spaces/by-subdomain/${e}` : `https://huggingface.co/api/spaces/${e}`, i, o;
  try {
    if (i = await fetch(n), o = i.status, o !== 200)
      throw new Error();
    i = await i.json();
  } catch {
    t({
      status: "error",
      load_status: "error",
      message: st,
      detail: "NOT_FOUND"
    });
    return;
  }
  if (!i || o !== 200) return;
  const {
    runtime: { stage: r },
    id: a
  } = i;
  switch (r) {
    case "STOPPED":
    case "SLEEPING":
      t({
        status: "sleeping",
        load_status: "pending",
        message: "Space is asleep. Waking it up...",
        detail: r
      }), setTimeout(() => {
        G(e, s, t);
      }, 1e3);
      break;
    case "PAUSED":
      t({
        status: "paused",
        load_status: "error",
        message: "This space has been paused by the author. If you would like to try this demo, consider duplicating the space.",
        detail: r,
        discussions_enabled: await Se(a)
      });
      break;
    case "RUNNING":
    case "RUNNING_BUILDING":
      t({
        status: "running",
        load_status: "complete",
        message: "Space is running.",
        detail: r
      });
      break;
    case "BUILDING":
      t({
        status: "building",
        load_status: "pending",
        message: "Space is building...",
        detail: r
      }), setTimeout(() => {
        G(e, s, t);
      }, 1e3);
      break;
    case "APP_STARTING":
      t({
        status: "starting",
        load_status: "pending",
        message: "Space is starting...",
        detail: r
      }), setTimeout(() => {
        G(e, s, t);
      }, 1e3);
      break;
    default:
      t({
        status: "space_error",
        load_status: "error",
        message: "This space is experiencing an issue.",
        detail: r,
        discussions_enabled: await Se(a)
      });
      break;
  }
}
const Pe = async (e, s) => {
  let t = 0;
  const n = 12, i = 5e3;
  return new Promise((o) => {
    G(
      e,
      ue.test(e) ? "space_name" : "subdomain",
      (r) => {
        s(r), r.status === "running" || r.status === "error" || r.status === "paused" || r.status === "space_error" ? o() : (r.status === "sleeping" || r.status === "building") && (t < n ? (t++, setTimeout(() => {
          Pe(e, s).then(o);
        }, i)) : o());
      }
    );
  });
}, Nt = /^(?=[^]*\b[dD]iscussions{0,1}\b)(?=[^]*\b[dD]isabled\b)[^]*$/;
async function Se(e) {
  try {
    const s = await fetch(
      `https://huggingface.co/api/spaces/${e}/discussions`,
      {
        method: "HEAD"
      }
    ), t = s.headers.get("x-error-message");
    return !(!s.ok || t && Nt.test(t));
  } catch {
    return !1;
  }
}
async function Dt(e, s) {
  const t = {};
  s && (t.Authorization = `Bearer ${s}`);
  try {
    const n = await fetch(
      `https://huggingface.co/api/spaces/${e}/${Ke}`,
      { headers: t }
    );
    if (n.status !== 200)
      throw new Error("Space hardware could not be obtained.");
    const { hardware: i } = await n.json();
    return i.current;
  } catch (n) {
    throw new Error(n.message);
  }
}
async function Pt(e, s, t) {
  const n = {};
  t && (n.Authorization = `Bearer ${t}`);
  const i = {
    seconds: s
  };
  try {
    const o = await fetch(
      `https://huggingface.co/api/spaces/${e}/${Ve}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json", ...n },
        body: JSON.stringify(i)
      }
    );
    if (o.status !== 200)
      throw new Error(
        "Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges."
      );
    return await o.json();
  } catch (o) {
    throw new Error(o.message);
  }
}
const $e = [
  "cpu-basic",
  "cpu-upgrade",
  "cpu-xl",
  "t4-small",
  "t4-medium",
  "a10g-small",
  "a10g-large",
  "a10g-largex2",
  "a10g-largex4",
  "a100-large",
  "zero-a10g",
  "h100",
  "h100x8"
];
async function Lt(e, s) {
  const { token: t, private: n, hardware: i, timeout: o, auth: r } = s;
  if (i && !$e.includes(i))
    throw new Error(
      `Invalid hardware type provided. Valid types are: ${$e.map((y) => `"${y}"`).join(",")}.`
    );
  const { http_protocol: a, host: u } = await le(e, t);
  let l = null;
  if (r) {
    const y = await xe(
      a,
      u,
      r,
      fetch
    );
    y && (l = Ce(y));
  }
  const p = {
    Authorization: `Bearer ${t}`,
    "Content-Type": "application/json",
    ...l ? { Cookie: l.join("; ") } : {}
  }, c = (await (await fetch("https://huggingface.co/api/whoami-v2", {
    headers: p
  })).json()).name, m = e.split("/")[1], w = {
    repository: `${c}/${m}`
  };
  n && (w.private = !0);
  let h;
  try {
    i || (h = await Dt(e, t));
  } catch (y) {
    throw Error(ce + y.message);
  }
  const D = i || h || "cpu-basic";
  w.hardware = D;
  try {
    const y = await fetch(
      `https://huggingface.co/api/spaces/${e}/duplicate`,
      {
        method: "POST",
        headers: p,
        body: JSON.stringify(w)
      }
    );
    if (y.status === 409)
      try {
        return await V.connect(`${c}/${m}`, s);
      } catch (P) {
        throw console.error("Failed to connect Client instance:", P), P;
      }
    else if (y.status !== 200)
      throw new Error(y.statusText);
    const Q = await y.json();
    return await Pt(`${c}/${m}`, o || 300, t), await V.connect(
      jt(Q.url),
      s
    );
  } catch (y) {
    throw new Error(y);
  }
}
function jt(e) {
  const s = /https:\/\/huggingface.co\/spaces\/([^/]+\/[^/]+)/, t = e.match(s);
  if (t)
    return t[1];
}
class It extends TransformStream {
  #e = "";
  /** Constructs a new instance. */
  constructor(s = { allowCR: !1 }) {
    super({
      transform: (t, n) => {
        for (t = this.#e + t; ; ) {
          const i = t.indexOf(`
`), o = s.allowCR ? t.indexOf("\r") : -1;
          if (o !== -1 && o !== t.length - 1 && (i === -1 || i - 1 > o)) {
            n.enqueue(t.slice(0, o)), t = t.slice(o + 1);
            continue;
          }
          if (i === -1)
            break;
          const r = t[i - 1] === "\r" ? i - 1 : i;
          n.enqueue(t.slice(0, r)), t = t.slice(i + 1);
        }
        this.#e = t;
      },
      flush: (t) => {
        if (this.#e === "")
          return;
        const n = s.allowCR && this.#e.endsWith("\r") ? this.#e.slice(0, -1) : this.#e;
        t.enqueue(n);
      }
    });
  }
}
function Ut(e) {
  let s = new TextDecoderStream(), t = new It({ allowCR: !0 });
  return e.pipeThrough(s).pipeThrough(t);
}
function qt(e) {
  let t = /[:]\s*/.exec(e), n = t && t.index;
  if (n)
    return [
      e.substring(0, n),
      e.substring(n + t[0].length)
    ];
}
function ke(e, s, t) {
  e.get(s) || e.set(s, t);
}
async function* zt(e, s) {
  if (!e.body)
    return;
  let t = Ut(e.body), n, i = t.getReader(), o;
  for (; ; ) {
    if (s && s.aborted)
      return i.cancel();
    if (n = await i.read(), n.done)
      return;
    if (!n.value) {
      o && (yield o), o = void 0;
      continue;
    }
    let [r, a] = qt(n.value) || [];
    r === "data" ? (o ||= {}, o[r] = o[r] ? o[r] + `
` + a : a) : r === "event" ? (o ||= {}, o[r] = a) : r === "id" ? (o ||= {}, o[r] = String(+a) === a ? +a : a) : r === "retry" && (o ||= {}, o[r] = +a || void 0);
  }
}
async function Bt(e, s) {
  let t = new Request(e, s);
  ke(t.headers, "Accept", "text/event-stream"), ke(t.headers, "Content-Type", "application/json");
  let n = await fetch(t);
  if (!n.ok)
    throw n;
  return zt(n, t.signal);
}
async function Ft() {
  let {
    event_callbacks: e,
    unclosed_events: s,
    pending_stream_messages: t,
    stream_status: n,
    config: i,
    jwt: o
  } = this;
  const r = this;
  if (!i)
    throw new Error("Could not resolve app config");
  n.open = !0;
  let a = null, u = new URLSearchParams({
    session_hash: this.session_hash
  }).toString(), l = new URL(`${i.root}${this.api_prefix}/${Re}?${u}`);
  if (o && l.searchParams.set("__sign", o), a = this.stream(l), !a) {
    console.warn("Cannot connect to SSE endpoint: " + l.toString());
    return;
  }
  a.onmessage = async function(p) {
    let c = JSON.parse(p.data);
    if (c.msg === "close_stream") {
      pe(n, r.abort_controller);
      return;
    }
    const m = c.event_id;
    if (!m)
      await Promise.all(
        Object.keys(e).map(
          (w) => e[w](c)
        )
      );
    else if (e[m] && i) {
      c.msg === "process_completed" && ["sse", "sse_v1", "sse_v2", "sse_v2.1", "sse_v3"].includes(
        i.protocol
      ) && s.delete(m);
      let w = e[m];
      typeof window < "u" && typeof document < "u" ? setTimeout(w, 0, c) : w(c);
    } else
      t[m] || (t[m] = []), t[m].push(c);
  }, a.onerror = async function(p) {
    console.error(p), await Promise.all(
      Object.keys(e).map(
        (c) => e[c]({
          msg: "broken_connection",
          message: M
        })
      )
    );
  };
}
function pe(e, s) {
  e && (e.open = !1, s?.abort());
}
function Gt(e, s, t) {
  !e[s] ? (e[s] = [], t.data.forEach((i, o) => {
    e[s][o] = i;
  })) : t.data.forEach((i, o) => {
    let r = Mt(e[s][o], i);
    e[s][o] = r, t.data[o] = r;
  });
}
function Mt(e, s) {
  return s.forEach(([t, n, i]) => {
    e = Jt(e, n, t, i);
  }), e;
}
function Jt(e, s, t, n) {
  if (s.length === 0) {
    if (t === "replace")
      return n;
    if (t === "append")
      return e + n;
    throw new Error(`Unsupported action: ${t}`);
  }
  let i = e;
  for (let r = 0; r < s.length - 1; r++)
    i = i[s[r]];
  const o = s[s.length - 1];
  switch (t) {
    case "replace":
      i[o] = n;
      break;
    case "append":
      i[o] += n;
      break;
    case "add":
      Array.isArray(i) ? i.splice(Number(o), 0, n) : i[o] = n;
      break;
    case "delete":
      Array.isArray(i) ? i.splice(Number(o), 1) : delete i[o];
      break;
    default:
      throw new Error(`Unknown action: ${t}`);
  }
  return e;
}
function Ht(e, s = {}) {
  const t = {
    close: () => {
      console.warn("Method not implemented.");
    },
    onerror: null,
    onmessage: null,
    onopen: null,
    readyState: 0,
    url: e.toString(),
    withCredentials: !1,
    CONNECTING: 0,
    OPEN: 1,
    CLOSED: 2,
    addEventListener: () => {
      throw new Error("Method not implemented.");
    },
    dispatchEvent: () => {
      throw new Error("Method not implemented.");
    },
    removeEventListener: () => {
      throw new Error("Method not implemented.");
    }
  };
  return Bt(e, s).then(async (n) => {
    t.readyState = t.OPEN;
    try {
      for await (const i of n)
        t.onmessage && t.onmessage(i);
      t.readyState = t.CLOSED;
    } catch (i) {
      t.onerror && t.onerror(i), t.readyState = t.CLOSED;
    }
  }).catch((n) => {
    console.error(n), t.onerror && t.onerror(n), t.readyState = t.CLOSED;
  }), t;
}
function Wt(e, s = {}, t, n, i) {
  try {
    let o = function(f) {
      (i || Ue[f.type]) && l(f);
    }, r = function() {
      for (Fe = !0; B.length > 0; )
        B.shift()({
          value: void 0,
          done: !0
        });
    }, a = function(f) {
      B.length > 0 ? B.shift()(f) : ne.push(f);
    }, u = function(f) {
      a(Zt(f)), r();
    }, l = function(f) {
      a({ value: f, done: !1 });
    }, p = function() {
      return ne.length > 0 ? Promise.resolve(ne.shift()) : new Promise((f) => B.push(f));
    };
    const { token: c } = this.options, {
      fetch: m,
      app_reference: w,
      config: h,
      session_hash: D,
      api_info: y,
      api_map: Q,
      stream_status: P,
      pending_stream_messages: X,
      pending_diff_streams: ee,
      event_callbacks: te,
      unclosed_events: Le,
      post_data: se,
      options: J,
      api_prefix: R
    } = this, je = this;
    if (!y) throw new Error("No API found");
    if (!h) throw new Error("Could not resolve app config");
    let { fn_index: d, endpoint_info: he, dependency: q } = Kt(
      y,
      e,
      Q,
      h
    ), Ie = mt(s, he), I, O = h.protocol ?? "ws";
    if (O === "ws")
      throw new Error("WebSocket protocol is not supported in this version");
    let U = "", Vt = () => U;
    const _ = typeof e == "number" ? "/predict" : e;
    let H, b = null, T = !1, de = {}, z = typeof window < "u" && typeof document < "u" ? new URLSearchParams(window.location.search).toString() : "";
    const Ue = J?.events?.reduce(
      (f, k) => (f[k] = !0, f),
      {}
    ) || {};
    async function qe() {
      let f = {}, k = {};
      f = { event_id: b }, k = { event_id: b, session_hash: D, fn_index: d };
      try {
        if (!h)
          throw new Error("Could not resolve app config");
        "event_id" in k && await m(`${h.root}${R}/${et}`, {
          headers: { "Content-Type": "application/json" },
          method: "POST",
          body: JSON.stringify(k)
        }), await m(`${h.root}${R}/${Xe}`, {
          headers: { "Content-Type": "application/json" },
          method: "POST",
          body: JSON.stringify(f)
        });
      } catch {
        console.warn(
          "The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable."
        );
      }
    }
    const ze = async (f) => {
      await this._resolve_heartbeat(f);
    };
    async function fe(f) {
      if (!h) return;
      let k = f.render_id;
      h.components = [
        ...h.components.filter((v) => v.props.rendered_in !== k),
        ...f.components
      ], h.dependencies = [
        ...h.dependencies.filter((v) => v.rendered_in !== k),
        ...f.dependencies
      ];
      const W = h.components.some((v) => v.type === "state"), g = h.dependencies.some(
        (v) => v.targets.some((L) => L[1] === "unload")
      );
      h.connect_heartbeat = W || g, await ze(h), o({
        type: "render",
        data: f,
        endpoint: _,
        fn_index: d
      });
    }
    const Be = this.handle_blob(
      h.root,
      Ie,
      he
    ).then(async (f) => {
      if (H = {
        data: K(
          f,
          q,
          h.components,
          "input",
          !0
        ) || [],
        event_data: t,
        fn_index: d,
        trigger_id: n
      }, kt(d, h))
        o({
          type: "status",
          endpoint: _,
          stage: "pending",
          queue: !1,
          fn_index: d,
          time: /* @__PURE__ */ new Date()
        }), se(
          `${h.root}${R}/run${_.startsWith("/") ? _ : `/${_}`}${z ? "?" + z : ""}`,
          {
            ...H,
            session_hash: D
          }
        ).then(async ([g, v]) => {
          const L = g.data;
          v == 200 ? (o({
            type: "data",
            endpoint: _,
            fn_index: d,
            data: K(
              L,
              q,
              h.components,
              "output",
              J.with_null_state
            ),
            time: /* @__PURE__ */ new Date(),
            event_data: t,
            trigger_id: n
          }), g.render_config && await fe(g.render_config), o({
            type: "status",
            endpoint: _,
            fn_index: d,
            stage: "complete",
            eta: g.average_duration,
            queue: !1,
            time: /* @__PURE__ */ new Date()
          })) : o({
            type: "status",
            stage: "error",
            endpoint: _,
            fn_index: d,
            message: g.error,
            queue: !1,
            time: /* @__PURE__ */ new Date()
          });
        }).catch((g) => {
          o({
            type: "status",
            stage: "error",
            message: g.message,
            endpoint: _,
            fn_index: d,
            queue: !1,
            time: /* @__PURE__ */ new Date()
          });
        });
      else if (O == "sse") {
        o({
          type: "status",
          stage: "pending",
          queue: !0,
          endpoint: _,
          fn_index: d,
          time: /* @__PURE__ */ new Date()
        });
        var W = new URLSearchParams({
          fn_index: d.toString(),
          session_hash: D
        }).toString();
        let g = new URL(
          `${h.root}${R}/${Re}?${z ? z + "&" : ""}${W}`
        );
        if (this.jwt && g.searchParams.set("__sign", this.jwt), I = this.stream(g), !I)
          return Promise.reject(
            new Error("Cannot connect to SSE endpoint: " + g.toString())
          );
        I.onmessage = async function(v) {
          const L = JSON.parse(v.data), { type: j, status: A, data: x } = be(
            L,
            de[d]
          );
          if (j === "update" && A && !T)
            o({
              type: "status",
              endpoint: _,
              fn_index: d,
              time: /* @__PURE__ */ new Date(),
              ...A
            }), A.stage === "error" && (I?.close(), r());
          else if (j === "data") {
            let [C, F] = await se(
              `${h.root}${R}/queue/data`,
              {
                ...H,
                session_hash: D,
                event_id: b
              }
            );
            F !== 200 && (o({
              type: "status",
              stage: "error",
              message: M,
              queue: !0,
              endpoint: _,
              fn_index: d,
              time: /* @__PURE__ */ new Date()
            }), I?.close(), r());
          } else j === "complete" ? T = A : j === "log" ? o({
            type: "log",
            title: x.title,
            log: x.log,
            level: x.level,
            endpoint: _,
            duration: x.duration,
            visible: x.visible,
            fn_index: d
          }) : (j === "generating" || j === "streaming") && o({
            type: "status",
            time: /* @__PURE__ */ new Date(),
            ...A,
            stage: A?.stage,
            queue: !0,
            endpoint: _,
            fn_index: d
          });
          x && (o({
            type: "data",
            time: /* @__PURE__ */ new Date(),
            data: K(
              x.data,
              q,
              h.components,
              "output",
              J.with_null_state
            ),
            endpoint: _,
            fn_index: d,
            event_data: t,
            trigger_id: n
          }), T && (o({
            type: "status",
            time: /* @__PURE__ */ new Date(),
            ...T,
            stage: A?.stage,
            queue: !0,
            endpoint: _,
            fn_index: d
          }), I?.close(), r()));
        };
      } else if (O == "sse_v1" || O == "sse_v2" || O == "sse_v2.1" || O == "sse_v3") {
        o({
          type: "status",
          stage: "pending",
          queue: !0,
          endpoint: _,
          fn_index: d,
          time: /* @__PURE__ */ new Date()
        });
        let g = "";
        typeof window < "u" && typeof document < "u" && (g = window?.location?.hostname);
        const L = g.includes(".dev.") ? `https://moon-${g.split(".")[1]}.dev.spaces.huggingface.tech` : "https://huggingface.co";
        return (typeof window < "u" && typeof document < "u" && window.parent != window && window.supports_zerogpu_headers ? Rt("zerogpu-headers", L) : Promise.resolve(null)).then((C) => se(
          `${h.root}${R}/${He}?${z}`,
          {
            ...H,
            session_hash: D
          },
          C
        )).then(async ([C, F]) => {
          if (C.event_id && (U = C.event_id), F === 503)
            o({
              type: "status",
              stage: "error",
              message: Oe,
              queue: !0,
              endpoint: _,
              fn_index: d,
              time: /* @__PURE__ */ new Date(),
              visible: !0
            });
          else if (F === 422)
            o({
              type: "status",
              stage: "error",
              message: C.detail,
              queue: !0,
              endpoint: _,
              fn_index: d,
              code: "validation_error",
              time: /* @__PURE__ */ new Date(),
              visible: !0
            }), r();
          else if (F !== 200)
            o({
              type: "status",
              stage: "error",
              broken: !1,
              message: C.detail,
              queue: !0,
              endpoint: _,
              fn_index: d,
              time: /* @__PURE__ */ new Date(),
              visible: !0
            });
          else {
            b = C.event_id, U = b;
            let me = async function(oe) {
              try {
                const { type: E, status: S, data: $, original_msg: Ge } = be(
                  oe,
                  de[d]
                );
                if (E == "heartbeat")
                  return;
                if (E === "update" && S && !T)
                  o({
                    type: "status",
                    endpoint: _,
                    fn_index: d,
                    time: /* @__PURE__ */ new Date(),
                    original_msg: Ge,
                    ...S
                  });
                else if (E === "complete")
                  T = S;
                else if (E == "unexpected_error" || E == "broken_connection") {
                  console.error("Unexpected error", S?.message);
                  const Me = E === "broken_connection";
                  o({
                    type: "status",
                    stage: "error",
                    message: S?.message || "An Unexpected Error Occurred!",
                    queue: !0,
                    endpoint: _,
                    broken: Me,
                    session_not_found: S?.session_not_found,
                    fn_index: d,
                    time: /* @__PURE__ */ new Date()
                  });
                } else if (E === "log") {
                  o({
                    type: "log",
                    title: $.title,
                    log: $.log,
                    level: $.level,
                    endpoint: _,
                    duration: $.duration,
                    visible: $.visible,
                    fn_index: d
                  });
                  return;
                } else (E === "generating" || E === "streaming") && (o({
                  type: "status",
                  time: /* @__PURE__ */ new Date(),
                  ...S,
                  stage: S?.stage,
                  queue: !0,
                  endpoint: _,
                  fn_index: d
                }), $ && q.connection !== "stream" && ["sse_v2", "sse_v2.1", "sse_v3"].includes(O) && Gt(ee, b, $));
                $ && (o({
                  type: "data",
                  time: /* @__PURE__ */ new Date(),
                  data: K(
                    $.data,
                    q,
                    h.components,
                    "output",
                    J.with_null_state
                  ),
                  endpoint: _,
                  fn_index: d
                }), $.render_config && await fe($.render_config), T && (o({
                  type: "status",
                  time: /* @__PURE__ */ new Date(),
                  ...T,
                  stage: S?.stage,
                  queue: !0,
                  endpoint: _,
                  fn_index: d
                }), r())), (S?.stage === "complete" || S?.stage === "error") && (te[b] && delete te[b], b in ee && delete ee[b]);
              } catch (E) {
                console.error("Unexpected client exception", E), o({
                  type: "status",
                  stage: "error",
                  message: "An Unexpected Error Occurred!",
                  queue: !0,
                  endpoint: _,
                  fn_index: d,
                  time: /* @__PURE__ */ new Date()
                }), ["sse_v2", "sse_v2.1", "sse_v3"].includes(O) && (pe(P, je.abort_controller), P.open = !1, r());
              }
            };
            b in X && (X[b].forEach((oe) => me(oe)), delete X[b]), te[b] = me, Le.add(b), P.open || await this.open_stream();
          }
        });
      }
    });
    let Fe = !1;
    const ne = [], B = [], _e = {
      [Symbol.asyncIterator]: () => _e,
      next: p,
      throw: async (f) => (u(f), p()),
      return: async () => (r(), { value: void 0, done: !0 }),
      cancel: qe,
      send_chunk: (f) => {
        this.post_data(`${h.root}${R}/stream/${U}`, {
          ...f,
          session_hash: this.session_hash
        });
      },
      close_stream: () => {
        this.post_data(
          `${h.root}${R}/stream/${U}/close`,
          {}
        ), r();
      },
      event_id: () => U,
      wait_for_id: async () => (await Be, b)
    };
    return _e;
  } catch (o) {
    throw console.error("Submit function encountered an error:", o), o;
  }
}
function Zt(e) {
  return {
    then: (s, t) => t(e)
  };
}
function Kt(e, s, t, n) {
  let i, o, r;
  if (typeof s == "number")
    i = s, o = e.unnamed_endpoints[i], r = n.dependencies.find((a) => a.id == s);
  else {
    const a = s.replace(/^\//, "");
    i = t[a], o = e.named_endpoints[s.trim()], r = n.dependencies.find(
      (u) => u.id == t[a]
    );
  }
  if (typeof i != "number")
    throw new Error(
      "There is no endpoint matching that name of fn_index matching that number."
    );
  return { fn_index: i, endpoint_info: o, dependency: r };
}
class V {
  app_reference;
  options;
  deep_link = null;
  config;
  api_prefix = "";
  api_info;
  api_map = {};
  session_hash = Math.random().toString(36).substring(2);
  jwt = !1;
  last_status = {};
  cookies = null;
  // streaming
  stream_status = { open: !1 };
  closed = !1;
  pending_stream_messages = {};
  pending_diff_streams = {};
  event_callbacks = {};
  unclosed_events = /* @__PURE__ */ new Set();
  heartbeat_event = null;
  abort_controller = null;
  stream_instance = null;
  current_payload;
  get_url_config(s = null) {
    if (!this.config)
      throw new Error(N);
    s === null && (s = window.location.href);
    const t = (r) => r.replace(/^\/+|\/+$/g, "");
    let n = t(new URL(this.config.root).pathname), i = t(new URL(s).pathname), o;
    return i.startsWith(n) ? o = t(i.substring(n.length)) : o = "", this.get_page_config(o);
  }
  get_page_config(s) {
    if (!this.config)
      throw new Error(N);
    let t = this.config;
    return s in t.page || (s = ""), {
      ...t,
      current_page: s,
      layout: t.page[s].layout,
      components: t.components.filter(
        (n) => t.page[s].components.includes(n.id)
      ),
      dependencies: this.config.dependencies.filter(
        (n) => t.page[s].dependencies.includes(n.id)
      )
    };
  }
  fetch(s, t) {
    const n = new Headers(t?.headers || {});
    if (this && this.cookies && n.append("Cookie", this.cookies), this && this.options.headers)
      for (const i in this.options.headers)
        n.append(i, this.options.headers[i]);
    return fetch(s, { ...t, headers: n });
  }
  stream(s) {
    const t = new Headers();
    if (this && this.cookies && t.append("Cookie", this.cookies), this && this.options.headers)
      for (const n in this.options.headers)
        t.append(n, this.options.headers[n]);
    return this && this.options.token && t.append("Authorization", `Bearer ${this.options.token}`), this.abort_controller = new AbortController(), this.stream_instance = Ht(s.toString(), {
      credentials: "include",
      headers: t,
      signal: this.abort_controller.signal
    }), this.stream_instance;
  }
  view_api;
  upload_files;
  upload;
  handle_blob;
  post_data;
  submit;
  predict;
  open_stream;
  resolve_config;
  resolve_cookies;
  constructor(s, t = { events: ["data"] }) {
    this.app_reference = s, this.deep_link = t.query_params?.deep_link || null, t.events || (t.events = ["data"]), this.options = t, this.current_payload = {}, this.view_api = gt.bind(this), this.upload_files = wt.bind(this), this.handle_blob = Ot.bind(this), this.post_data = xt.bind(this), this.submit = Wt.bind(this), this.predict = Ct.bind(this), this.open_stream = Ft.bind(this), this.resolve_config = lt.bind(this), this.resolve_cookies = pt.bind(this), this.upload = St.bind(this), this.fetch = this.fetch.bind(this), this.handle_space_success = this.handle_space_success.bind(this), this.stream = this.stream.bind(this);
  }
  async init() {
    this.options.auth && await this.resolve_cookies(), await this._resolve_config().then(
      ({ config: s }) => this._resolve_heartbeat(s)
    ), this.api_info = await this.view_api(), this.api_map = ut(this.config?.dependencies || []);
  }
  async _resolve_heartbeat(s) {
    if (s && (this.config = s, this.api_prefix = s.api_prefix || "", this.config && this.config.connect_heartbeat && this.config.space_id && this.options.token && (this.jwt = await we(
      this.config.space_id,
      this.options.token,
      this.cookies
    ))), s.space_id && this.options.token && (this.jwt = await we(s.space_id, this.options.token)), this.config && this.config.connect_heartbeat) {
      const t = new URL(
        `${this.config.root}${this.api_prefix}/${Ye}/${this.session_hash}`
      );
      this.jwt && t.searchParams.set("__sign", this.jwt), this.heartbeat_event || (this.heartbeat_event = this.stream(t));
    }
  }
  static async connect(s, t = {
    events: ["data"]
  }) {
    const n = new this(s, t);
    return t.session_hash && (n.session_hash = t.session_hash), await n.init(), n;
  }
  async reconnect() {
    const s = new URL(
      `${this.config.root}${this.api_prefix}/${tt}`
    );
    let t;
    try {
      const n = await this.fetch(s);
      if (!n.ok)
        throw new Error();
      t = (await n.json()).app_id;
    } catch {
      return "broken";
    }
    return t !== this.config.app_id ? "changed" : "connected";
  }
  close() {
    this.closed = !0, pe(this.stream_status, this.abort_controller);
  }
  set_current_payload(s) {
    this.current_payload = s;
  }
  static async duplicate(s, t = {
    events: ["data"]
  }) {
    return Lt(s, t);
  }
  async _resolve_config() {
    const { http_protocol: s, host: t, space_id: n } = await le(
      this.app_reference,
      this.options.token
    ), { status_callback: i } = this.options;
    n && i && await Pe(n, i);
    let o;
    try {
      let r = `${s}//${t}`;
      if (o = await this.resolve_config(r), !o)
        throw new Error(N);
      return this.config_success(o);
    } catch (r) {
      if (n && i)
        G(
          n,
          ue.test(n) ? "space_name" : "subdomain",
          this.handle_space_success
        );
      else
        throw i && i({
          status: "error",
          message: "Could not load this space.",
          load_status: "error",
          detail: "NOT_FOUND"
        }), Error(r);
    }
  }
  async config_success(s) {
    if (this.config = s, this.api_prefix = s.api_prefix || "", this.config.auth_required)
      return this.prepare_return_obj();
    try {
      this.api_info = await this.view_api();
    } catch (t) {
      console.error(nt + t.message);
    }
    return this.prepare_return_obj();
  }
  async handle_space_success(s) {
    if (!this)
      throw new Error(N);
    const { status_callback: t } = this.options;
    if (t && t(s), s.status === "running")
      try {
        if (this.config = await this._resolve_config(), this.api_prefix = this?.config?.api_prefix || "", !this.config)
          throw new Error(N);
        return await this.config_success(this.config);
      } catch (n) {
        throw t && t({
          status: "error",
          message: "Could not load this space.",
          load_status: "error",
          detail: "NOT_FOUND"
        }), n;
      }
  }
  async component_server(s, t, n) {
    if (!this.config)
      throw new Error(N);
    const i = {}, { token: o } = this.options, { session_hash: r } = this;
    o && (i.Authorization = `Bearer ${this.options.token}`);
    let a, u = this.config.components.find(
      (p) => p.id === s
    );
    u?.props?.root_url ? a = u.props.root_url : a = this.config.root;
    let l;
    if ("binary" in n) {
      l = new FormData();
      for (const p in n.data)
        p !== "binary" && l.append(p, n.data[p]);
      l.set("component_id", s.toString()), l.set("fn_name", t), l.set("session_hash", r);
    } else
      l = JSON.stringify({
        data: n,
        component_id: s,
        fn_name: t,
        session_hash: r
      }), i["Content-Type"] = "application/json";
    o && (i.Authorization = `Bearer ${o}`);
    try {
      const p = await this.fetch(
        `${a}${this.api_prefix}/${Qe}/`,
        {
          method: "POST",
          body: l,
          headers: i,
          credentials: "include"
        }
      );
      if (!p.ok)
        throw new Error(
          "Could not connect to component server: " + p.statusText
        );
      return await p.json();
    } catch (p) {
      console.warn(p);
    }
  }
  set_cookies(s) {
    this.cookies = Ce(s).join("; ");
  }
  prepare_return_obj() {
    return {
      config: this.config,
      predict: this.predict,
      submit: this.submit,
      view_api: this.view_api,
      component_server: this.component_server
    };
  }
}
async function Xt(e, s = {
  events: ["data"]
}) {
  return await V.connect(e, s);
}
async function es(e, s) {
  return await V.duplicate(e, s);
}
export {
  V as Client,
  Y as FileData,
  rt as MISSING_CREDENTIALS_MSG,
  Xt as client,
  es as duplicate,
  Qt as handle_file,
  Ct as predict,
  Yt as prepare_files,
  Wt as submit,
  St as upload,
  wt as upload_files
};
